#include <stdio.h>
#include <stdlib.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <dirent.h>
#include <sys/wait.h>
#include <math.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <netdb.h>
#include "llist.h"
#include <sys/mman.h>
#include <semaphore.h>
#define size_id 6

//RESTURANT

typedef struct data_t{
	int hold;
	int connfd;	
}Data_t; // per il passaggio dei dati nel thread

void* thread_function(void*args);

int listenfd;
int *sig;
list* ordini;
list* riders;
int *rider_cout;
int *listenfd;
int maxfd;

int main(int argc, char ** argv) {

	/* creazione menu */
	int n_items=5;
	char *items[n_items];
	float prezzo[n_items];
	items[0]="cocacol";	
	items[1]="purpett";
	items[2]="patan";
	items[3]="zampon";
	items[4]="zeppl";
	prezzo[0]=1.5;
	prezzo[1]=3.5;
	prezzo[2]=4.0;
	prezzo[3]=1.0;
	prezzo[4]=1.5;
	Menu *m;
	m->items=items;
	m->prezzo=prezzo;
	m->n_items;
	

/* ############## INIZIO CONNESSIONE ########################## */
    if (argc < 2) {
    // poichè è un server "locale" si usa l'ip 127.0.0.1
        fprintf(stderr, "usage: %s <IPaddress>\n", argv[0]);
        exit(1);
    }
    int sockfd;
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        fprintf(stderr, "socket error\n");
        exit(1);
    }
   	// tutte le caratteristiche che permettorno l'interconnessione con il server
    struct sockaddr_in servaddr;
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(2001);
    // conversione ip
    if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) < 0) {
        fprintf(stderr, "inet_pton error for %s\n", argv[1]);
        exit(1);
    }
    // connessione bloccante
    if (connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
        fprintf(stderr, "connect error\n");
        exit(1);
    }
/* ############## FINE CONNESSIONE ########################## */

	/* ristorante si identifica "1" -> user;  "2"-> ristorante */
	int type = 2;
	send(sockfd, &type, sizeof(int), 0);
	
	/* invia Rist_R (nome+menu) al server */
	char*nome_rist="Palapizza";
	Rist_R *r;
	r->nome_rist=nome_rist;
	r->M=m;
	send(sockfd, r, sizeof(r), 0);
    

/* ############################################################ */
    
   	ordini = create_list(); //alloco lista per gli ordini
   	riders = create_list(); //alloco lista per i riders
   	rider_count=malloc(sizeof(int)); // count dei rider
   	rider_count=0;
	
	/* APRO IL THREAD PER APRIRE E GESTIRE LA CONNESSIONE CON I RIDER IN INGRESSO */
	pthread_t accept_t;
	pthread_create( &accept_t, NULL, main_thread, (void*) &dd);
    
    int loop1=1;
    int loop2=1;
    int loop3=1;
    int flag_o;
    char*rider_chosen;
    
    
	while(loop1){
	
		/* aspetta e legge ordine dal server */
		Ordine *o;
		read(sockfd, &o, sizeof(o));
		
		// setto variabili di controllo come nulle
		flag_o=0;
		rider_chosen=(char*)NULL;
		
		/* #### operazione gestione ordini ####*/
		while(loop2){
		
			/* invio messaggio a tutti i rider */
			send_message(riders);
			
			maxd = find_max_fd(riders, listenfd); // alternativa semplice con FD_SETSIZE
			
		    for (i = 1; i < FD_SETSIZE; i++){
				client[i] = -1;
			}
			//cliet [0]=listenfd; //non voglio gestire qui le connessioni
			client[maxd]=1;
			FD_ZERO(&allset);
		   	FD_SET(list_fd, &allset);
	   									

			rset = allset;
			// aspetta e controlla QUANTI descrittori (rider) sono disponibili per lettura
			ready = select(maxd+1, &rset, NULL,NULL,NULL);
			if(FD_ISSET(list_fd, &rset)){ //non voglio gestire qui le connessioni
				continue;
			}
			
			// controlla tutti i socket di ascolto se sono leggibili
			for( i = 0; i <= maxi; i++ ) {
	
	   			if( (sockd = client[i]) < 0 ) 
	   				continue;
			
	   			// se un socket è leggibile
	   			if ( FD_ISSET(sockd, &rset) ) {
	   			
	   				// legge sul sockd -> esegue operazioni
	   				/** leggo messaggio di risposta **/
		   			
		   				// chiude il sockd con la close
		   				if( close(sockd) == -1 )
		   					perror("errore nella close");
		   					
		   				// pulisce con FD_CLR	
		   				FD_CLR(sockd, &allset); 
		   				
		   				// resetta la disponibilità dell'i-esimo fd
		   				client[i] = -1; 
		   			}  
		   			
   			
	   			// Cicla finché ci sono ancora descrittori da controllare, una volta finito i descrittori, esce semplicemente
				if ( --ready <= 0 )  
					break;
			}	
			
		}
	
	}
	
	
	printf("\n Uscito dalla socket");
	close(listenfd);
	exit(1);
}


void*  main_thread (void *args){

/* ############## INIZIALIZZAZIONE SOCKET ##################### */
// INIZIALIZZARE LE SOCKET

	listenfd=malloc(sizeof(int));
    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket fd1");
        exit(1);
    }
// ISTANZIARE UNA SOCKET
    struct sockaddr_in servaddr1;
    servaddr1.sin_family = AF_INET;
    servaddr1.sin_port = htons(2002); //2001 per server
    servaddr1.sin_addr.s_addr = htonl(INADDR_ANY);
// RESUSE ADDR E PORT    
    int enable=1;
    if(setsockopt(listenfd, SOL_SOCKET,SO_REUSEADDR, &enable, sizeof(int)) < 0){
    	perror("setsockopt->ADDR fd1");
    	exit(1);
    }
    if(setsockopt(listenfd, SOL_SOCKET,SO_REUSEPORT, &enable, sizeof(int)) < 0){
    	perror("setsockopt->PORT fd1");
    	exit(1);
    }
// BIND
    if (bind(listenfd, (struct sockaddr *) &servaddr1, sizeof(servaddr1)) < 0) {
        perror("bind fd1");
        exit(1);
    }
// LISTEN
    if (listen(listenfd, 300) < 0) {
        perror("listen fd1");
        exit(1);
    }
/* ############## FINE INIZIALIZZAZIONE SOCKET ################ */

    int  connfd;
    struct sockaddr_in clientaddr;
    socklen_t size= sizeof(clientaddr);



	printf("\n SOCKET ATTIVA \n");
	
//////////// PARTE GESTIONE INIZIALE THREAD ///////////////////	
	// dichiarazione e inizializzazione disponibilità thread	
	int k=3; // n thread
	pthread_t tid1[k]; 
	sig=malloc(k*sizeof(int));
	for (int i=0;i<k;i++){
		sig[k]=0;
	}
	int l; // variabile per ricerca secondaria thread 
	int hold; // variabile per memorizzare indice disponibile
	Data_t dd; // per passare informazioni al thread
//////////// FINE GESTIONE INIZIALE THREAD ///////////////////	


    while (count_rider>-1) { // loop
	 	
	 	printf("\n bloccato sull'accept (%d)\n",ccc);
	 	connfd = accept(listenfd, (struct sockaddr *) &clientaddr, &size);
	   	
  	//------->>>> controlla quale thread è disponibile consultando l'array delle flag: 0 libero, -1 occupato
	   	printf("\n inizio controllo thread libero");
	   	l=-1;
	   	while(sig[ccc%k]==-1 && l==-1){ // thread ccc%k non disponibile
	   		l=0;
	   		while(sig[l%k]==-1){
	   			l++;
	   		}
	   	}
		if(l==-1) 
			hold=ccc%k;
		else
			hold=l%k;
		sig[hold]=-1; // indico che il thread trovato non è più "libero"
		printf("\n thread libero trovato: %d, lo setto occupato", hold);
		// istanzio le variabili personali da passare al thread
		dd.hold=hold;
		dd.connfd=connfd;
  	//------->>>> fine controllo 
		
		// inizializzazione thread
		pthread_create( &tid1[hold], NULL, thread_function, (void*) &dd);
		//pthread_join(tid1[hold], (void * ) NULL); //non aspetto che il thread finisca
	    
	}
}



void* thread_function (void *args){
	
	printf("\n inizio thread:");
	
	// prendo le info per la connessione passate dal main
	Data_t *d = (Data_t*) args;	
	int connfd = d->connfd;
	int ho = d->hold;
	
	/* controlla che tipo di client sei */
	int type;
	read(connfd, &type, sizeof(type));
	
	/* ricavo id_rider */
	char *id_rider;
	id_client=rand_string(id_rider,size_id);
	//invio id_client creato;
	send(connfd, id_rider, sizeof(id_rider), 0);	
	
	/* ricava la Rider_R e la inserisce nella lista*/
    push_front(riders, create_Rider_R(id_rider,connfd);
    
    /* incrementa il contatore */
    rider_count++;

	sig[ho]=0;		
	pthread_exit((void * ) NULL);
}





